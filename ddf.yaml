# ESPHome Dynamic Deadband Filter (DDF)
# This lambda filter implements a dynamic deadband that:
# - Tracks upper and lower bounds that expand when data exceeds them
# - Maintains a deadband (range between bounds)
# - Slides the deadband when trend continues in same direction
# - Expands bounds independently when trend reverses

# - Behavior:
#   * When trending up and value exceeds upper_bound: deadband slides up
#   * When trending down and value below lower_bound: deadband slides down
#   * When trend reverses: bounds expand independently:
#     - When trending up and value exceeds upper_bound: upper_bound expands
#     - When trending down and value below lower_bound: lower_bound expands 
#   * Return value is always the center of the deadband: (upper_bound + lower_bound) / 2

# ============================================================================
# Lambda Filter Implementation
# ============================================================================
# Use this lambda filter in the 'filters:' section of any sensor.

# Core DDF Lambda Filter:
# -----------------------
- lambda: |-
    static float upper_bound = NAN;
    static float lower_bound = NAN;
    static float previous_value = NAN;
    static int trend = 0; // -1 = down, 0 = neutral, 1 = up
    static float deadband_size = 0.0; // Initial deadband size
    
    float current_value = x;
    
    // Initialize bounds on first reading
    if (isnan(upper_bound) || isnan(lower_bound)) {
      upper_bound = current_value + deadband_size / 2.0;
      lower_bound = current_value - deadband_size / 2.0;
      previous_value = current_value;
      trend = 0;
      return (upper_bound + lower_bound) / 2.0;
    }
    
    // Determine current trend direction
    int current_trend = 0;
    if (current_value > previous_value) {
      current_trend = 1; // Trending up
    } else if (current_value < previous_value) {
      current_trend = -1; // Trending down
    } else {
      current_trend = trend; // Maintain previous trend if no change
    }
    
    // Check if trend has reversed
    bool trend_reversed = (trend != 0 && current_trend != 0 && trend != current_trend);
    
    // Update bounds based on behavior
    if (trend_reversed) {
      // Trend reversed: expand bounds independently
      if (current_value > upper_bound) {
        upper_bound = current_value;
      }
      if (current_value < lower_bound) {
        lower_bound = current_value;
      }
    } else {
      // Trend continues or neutral: slide deadband or expand independently
      if (current_trend == 1 && current_value > upper_bound) {
        // Trending up and exceeded upper bound: slide deadband up
        float excess = current_value - upper_bound;
        upper_bound = current_value;
        lower_bound += excess; // Slide lower bound up by same amount
      } else if (current_trend == -1 && current_value < lower_bound) {
        // Trending down and below lower bound: slide deadband down
        float excess = lower_bound - current_value;
        lower_bound = current_value;
        upper_bound -= excess; // Slide upper bound down by same amount
      } else {
        // Value within bounds or trend doesn't match: expand independently
        if (current_value > upper_bound) {
          upper_bound = current_value;
        }
        if (current_value < lower_bound) {
          lower_bound = current_value;
        }
      }
    }
    
    // Update state
    previous_value = current_value;
    trend = current_trend;
    

    return (upper_bound + lower_bound) / 2.0;

# ============================================================================
# Example Usage
# ============================================================================

# Example 1: Apply DDF to a temperature sensor
# sensor:
#   - platform: dht
#     temperature:
#       name: "Living Room Temperature"
#       id: temp_sensor
#       filters:
#         - filter_out: 0.0 # if the sensor tends to send useless values, use this before ddf to reduce noise
#         - lambda: |-
#             // add the above code here
#         - heartbeat: 500  # or any other filters

# ============================================================================
# Notes
# ============================================================================
# 1. Don't use median, EMA, SWMA, throttle_average, quantile before ddf, as they will reduce accuracy and add latency.
# 2. Don't use debounce, heartbeat,throttle, min, max, round, before ddf, as they will reduce accuracy
# 3. You shouldn't need to use any smoothing filter after ddf.
# 4. Filters that might be useful after ddf: calibrate, clamp, delta, heartbeat, throttle, max, min, multiply, offset, quantile, round.
# 5. Calibration filters can be used before or after ddf.