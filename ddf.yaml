# ExperimentalDynamic Deadband Filter (DDF) for ESPHome 
# This lambda filter implements a dynamic deadband that:
# - Tracks upper and lower bounds that expand when data exceeds them
# - Maintains a deadband (range between bounds)
# - Slides the deadband when trend continues in same direction
# - Expands bounds independently when trend reverses

# This should eliminate most of the noise from the sensor, like a moving average, median, or EMA filter.
# However, this filter adds no latency. Actual value changes are immediate.
# No tuning is needed, just apply the filter to the sensor.
# This filter uses very little memory, as only 6 static variables are used.
# Maybe 1 in 1000 raw samples the filtered output will actually be noise. This is because the errors follow a normal distribution.

# - Behavior:
#   * When trending up and value exceeds upper_bound: deadband slides up
#   * When trending down and value below lower_bound: deadband slides down
#   * When trend reverses: bounds expand independently:
#     - When trending up and value exceeds upper_bound: upper_bound expands
#     - When trending down and value below lower_bound: lower_bound expands 
#   * Return value is always the center of the deadband: (upper_bound + lower_bound) / 2

# ============================================================================
# Lambda Filter Implementation
# ============================================================================
# Use this lambda filter in the 'filters:' section of any sensor.

# Core DDF Lambda Filter:
# -----------------------
- lambda: |-
    static float upper_bound = NAN;
    static float lower_bound = NAN;
    static float previous_value = NAN;
    static int trend = 0; // -1 = down, 0 = neutral, 1 = up
    static float deadband_size = 0.0; // Initial deadband size
    static float contraction_factor = 0.998; // Deadband contraction factor (0.2% reduction)
    
    float current_value = x;
    
    // Initialize bounds on first reading
    if (isnan(upper_bound) || isnan(lower_bound)) {
      upper_bound = current_value + deadband_size / 2.0;
      lower_bound = current_value - deadband_size / 2.0;
      previous_value = current_value;
      trend = 0;
      return (upper_bound + lower_bound) / 2.0;
    }
    
    // Determine current trend direction
    int current_trend = 0;
    if (current_value > previous_value) {
      current_trend = 1; // Trending up
    } else if (current_value < previous_value) {
      current_trend = -1; // Trending down
    } else {
      current_trend = trend; // Maintain previous trend if no change
    }
    
    // Check if trend has reversed
    bool trend_reversed = (trend != 0 && current_trend != 0 && trend != current_trend);
    
    // Check if bounds are exceeded
    bool upper_exceeded = current_value > upper_bound;
    bool lower_exceeded = current_value < lower_bound;
    
    // Update bounds based on behavior
    if (trend_reversed) {
      // Case 3: Trend reversal with bound exceeded
      // Only move the bound in question, leave the other untouched. Update deadband_size.
      if (upper_exceeded) {
        upper_bound = current_value;
        deadband_size = upper_bound - lower_bound;
      } else if (lower_exceeded) {
        lower_bound = current_value;
        deadband_size = upper_bound - lower_bound;
      } else {
        // Case 2: Trend reversal without exceeding bound
        // Move bounds toward each other by 0.2%
        float center = (upper_bound + lower_bound) / 2.0;
        float current_deadband = upper_bound - lower_bound;
        // Contract deadband by 0.2%
        deadband_size = current_deadband * contraction_factor;
        // Recalculate bounds centered around the same center
        upper_bound = center + deadband_size / 2.0;
        lower_bound = center - deadband_size / 2.0;
      }
    } else {
      // No trend reversal
      if (upper_exceeded || lower_exceeded) {
        // Case 1: Bound exceeded without trend reversal
        // Move the bound in question and the opposite bound by the same amount, keeping deadband unchanged
        if (upper_exceeded) {
          float excess = current_value - upper_bound;
          upper_bound = current_value;
          lower_bound += excess; // Slide lower bound up by same amount
        } else if (lower_exceeded) {
          float excess = lower_bound - current_value;
          lower_bound = current_value;
          upper_bound -= excess; // Slide upper bound down by same amount
        }
        // deadband_size remains unchanged (sliding behavior)
      }
      // If no bound exceeded and no trend reversal, do nothing
    }
    
    // Update state
    previous_value = current_value;
    trend = current_trend;
    

    return (upper_bound + lower_bound) / 2.0;

# ============================================================================
# Example Usage
# ============================================================================

# Example 1: Apply DDF to a temperature sensor
# sensor:
#   - platform: dht
#     temperature:
#       name: "Living Room Temperature"
#       id: temp_sensor
#       filters:
#         - filter_out: 0.0 # if the sensor tends to send useless values, use this before ddf to reduce noise
#         - lambda: |-
#             // add the above code here
#         - heartbeat: 500  # or any other filters

# ============================================================================
# Notes
# ============================================================================
# 1. Don't use median, EMA, SWMA, throttle_average, quantile before ddf, as they will reduce accuracy and add latency.
# 2. Don't use debounce, heartbeat,throttle, min, max, round, before ddf, as they will reduce accuracy
# 3. You shouldn't need to use any smoothing filter after ddf.
# 4. Filters that might be useful after ddf: calibrate, clamp, delta, heartbeat, throttle, max, min, multiply, offset, quantile, round.
# 5. Calibration filters can be used before or after ddf.